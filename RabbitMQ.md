# RabbitMQ 分享

## 1. 内容列表
- [1. 内容列表](#1-内容列表)
- [2. 什么是消息队列](#2-什么是消息队列)
- [3. 为什么会有消息队列](#3-为什么要有消息队列)

## 2. 什么是消息队列
消息排队允许应用程序通过相互发送消息进行通信。当目标程序繁忙或未连接时，消息队列将提供临时消息存储[1]。
消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载[2]。
![message queue](https://github.com/meiyingqishi/Images/blob/main/message-queue-small.png)

## 3. 为什么会有消息队列
为了获得[3]：
- 更好的性能
> 消息队列支持异步通信，这意味着创建和处理消息的终端节点将与队列进行交互，而不是彼此交互。创建器可以将请求添加到队列中，无需再等待这些请求接受处理。处理器仅在消息可用时才会处理消息。系统中的任何组件都不会停下等待其他组件，从而优化了数据流。

- 增强的可靠性
> 队列可永久保留您的数据，并减少系统的不同部件离线时发生的错误。通过利用消息队列分离不同的组件，可以提高容错性。即使系统的某一部分无法访问，其他部分也仍可继续与队列进行交互。队列本身也可以进行镜像，以提供更高的可用性。

- 细化的可扩展性
> 消息队列可根据您的需要精确扩展。当工作负载到达峰值时，应用程序的多个实例都可以将请求添加到队列，而且不会产生冲突。随着队列因这些传入请求的增多而越来越长，您可以将这些工作负载分发给一组处理器。创建器、处理器和队列本身都可以按需扩展和缩减。

- 简化的分离功能
> 消息队列消除了组件之间的依赖关系，并显著简化了分离应用程序的编码。软件组件不必承担通信代码的重压，而是可以在经过设计后执行离散的业务功能。

## 4. 消息队列产生前都是怎样玩的
当大量写请求，或者具体的说应该是瞬时大量的写请求到来时，既要保证系统的可用性还要保证尽量全部处理掉请求的情况下，我们应该怎么处理呢？
- **线程池**：池化技术在我们日常开发中是缓解系统压力的一个重要利器，但是对于线程池而言很难根据系统的瞬时流量来自动伸缩容量，而且自动伸缩流量并不是根治大流量到来办法。当池子满了以后也会影响部分情况的丢弃，最重要的是一旦服务宕机，那么所有的请求将化为乌有，除非你将线程池序列化，自己想想复杂度跟性能吧。
- **队列/缓存**：队列一般场景下都是使用空间换时间的另一种常用办法，但是它的弊病也存在需要自己开发一套序列化方案，保证服务异常恢复能正常处理后续任务。Redis的发布订阅者同样存在这些问题。

## 5. 什么是RabbitMQ
RabbitMQ是一个免费的，开源的，可扩展的消息队列解决方案。 它是一个消息代理，可以理解AMQP（高级消息队列协议），但也可以与其他流行的消息解决方案（例如MQTT）一起使用。 它具有高可用性、容错性和可扩展性。 它在Erlang OTP中实现，该技术专为构建稳定、可靠、容错和高度可扩展的系统而设计，该系统具有处理大量并发操作的本机功能，例如RabbitMQ和其他系统（例如WhatsApp、MongooseIM等几个）。

在非常高的层次上，它是一个中间件层，使您的应用程序中的不同服务可以彼此通信，而不必担心消息丢失，同时提供不同的服务质量（QoS）要求。 它还可以实现细粒度和高效的消息路由，从而实现应用程序的广泛解耦[4]。

![rabbitmq flow](https://github.com/meiyingqishi/Images/blob/main/workflow-rabbitmq.png)

## 6. 为什么会有RabbitMQ
在1983年，当时一位26岁的工程师来自孟买有一个根本性的问题：为什么没有通用的软件“总线” —一种通信系统，可以从
一个对另一个感兴趣的应用程序？来自硬件设计方面的教育
在麻省理工学院，VivekRanadivé设想了一种通用总线，例如主板上的总线，
这将是应用程序可以插入的软件总线。 （请参阅http：//
hbswk.hbs.edu/archive/1884.html。）因此Teknekron于1983年出生。一个新鲜的
Vivek掌握了哈佛MBA的学识，脑海里浮现出这个强大的主意
开辟一条道路，将对各地的开发人员有所帮助。
 有这个主意是一回事，但为此找到一个杀手级应用是一回事
完全不同。 1985年，在高盛（Goldman Sachs），拉纳迪夫（Ranadivé）找到了他的第一个
客户以及他的软件总线应运而生的要解决的问题：金融交易。一种
当时商人的摊位装满了各种类型的不同终端的边缘
交易员完成工作所需的信息。 Teknekron看到了一个机会
更换所有这些端子及其孤立的应用程序。取而代之的是
Ranadivé的软件总线。剩下的将是一个工作站，其显示程序现在可以作为用户和用户插入Teknekron软件总线。
允许交易者“订阅”交易者想要查看的信息。发布订阅（PubSub）诞生了，世界上第一个现代消息队列软件也诞生了：Teknekron的信息总线（TIB）。
 这种数据传输模型很快就发现了更多杀手级用途。
毕竟，发布数据的应用程序和使用它的应用程序不再
必须直接相互连接。哎呀，他们甚至不必互相认识
存在。 Teknekron的TIB允许应用程序开发人员做的是建立一套
描述消息内容的规则集。只要消息被发布
根据这些规则，任何使用中的应用程序都可以订阅
带有感兴趣的主题标签的消息。现在，信息的生产者和消费者可以完全脱钩，并且可以即时灵活地混合在一起。的任一侧
PubSub模型（生产者/消费者）可以完全互换，而无需
打破另一面。唯一需要保持稳定的就是TIB
软件以及标记和路由信息的规则。自财务
贸易行业充满了信息，并且对信息的兴趣不断变化
乡亲们，TIB在该领域像野火一样蔓延。

电信尤其是新闻机构也注意到了这一点，他们也掌握了需要及时提供给动态变化的感兴趣的消费者的信息。这就是为什么大新闻适合路透社在1994年收购Teknekron的原因。
 同时，蓝色巨人并没有注意到新兴的企业软件这一新领域。毕竟，IBM的许多最大客户都是金融服务行业。此外，Teknekron的TIB软件经常在IBM硬件上运行，并且
操作系统……所有这些都没有让White Plains的男生受到打击。因此，在后期
上世纪80年代，IBM利用开发DB2的丰富信息交付经验，开始研究开发自己的消息队列软件。
http://www-01.ibm.com/software/integration/wmq/MQ15Anniversary.html）。开发始于1990年，位于美国温彻斯特附近的IBM Hursely Park Laboratories
王国。三年后出现的是IBM MQSeries消息队列服务器软件系列。从那以后的17年中，MQSeries已经发展成为WebSphere。
MQ和是当今占主导地位的商业消息队列平台。在那期间
那时，拉纳迪夫（Ranadivé）的TIB几乎没有消失在路透社的大肠内。相反，它有
通过重命名Rendezvous和Teknekron重新崛起为企业独立公司，仍然是企业消息传递中的另一个主要参与者。
于1997年成为TIBCO的形式。同年，微软在消息传递市场上取得了第一个突破
出现：Microsoft消息队列（MSMQ）。
 在所有这些演变过程中，消息队列（MQ）软件主要保留了下来
预算庞大的组织领域，需要可靠的，分离的实时消息传递。 MQ为什么没有找到更大的受众？它是如何生存的
信息热潮是90年代后期的互联网泡沫，而没有经历爆炸性的采用？毕竟，今天从Twitter到Salesforce.com的每个人都在争先恐后
为Information Bus解决的PubSub问题创建内部解决方案
25年前。两个词：供应商锁定。商业MQ供应商希望提供帮助
应用程序可以互操作，而不是创建允许不同接口的标准接口
要互操作的MQ产品，或者禁止天堂使用的MQ产品，允许应用程序更改MQ平台格式。供应商锁定使价格和利润保持高位，而商用MQ软件
超出了如今众多的初创公司和Web 2.0公司的能力。
 事实证明，并非只有小型科技公司对此感到不满
MQ供应商的高价围墙花园。那些金融服务公司
也不为MQ业的面包和黄油所困扰。不可避免地，
金融公司的规模意味着MQ产品来自多个供应商，为不同的内部应用程序提供服务。如果订阅TIBCO MQ信息的应用程序突然需要使用来自IBM MQ的消息，则它将
很难做到的。他们使用了不同的API，不同的有线协议，并且最终无法将它们联合在一起成为一条总线。从这个问题诞生了
2001年的Java消息服务（JMS）。 JMS试图通过提供隐藏对各个供应商MQ的实际接口的通用Java API来解决锁定和互操作性问题。
产品。从技术上讲，只需将Java应用程序写入JMS API，
选择的适当的MQ驱动程序。 JMS负责其余的工作……据推测。

问题是您要在多个不同的界面上粘贴单个标准界面。 就像将不同类型的布料粘合在一起：最终接缝分开了
现实突破了。 使用JMS，应用程序可能变得更加脆弱，而不是
较少的。 需要一种基于标准的新消息传递方法。

**AMQP进行救援**
2004年，摩根大通（JPMorgan Chase）需要更好地解决该问题，并开始与iMatix Corporation合作开发高级消息队列协议（AMQP）（请参阅
http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol#Development）。
一开始的AMQP被设计为一种开放标准，可以解决
大多数消息排队需求和拓扑。 通过成为一个开放的标准，任何人都可以实施它，并且按照该标准进行编码的任何人都可以进行互操作
与任何AMQP供应商的MQ服务器配合使用。
  AMQP从许多方面保证将我们从供应商的地牢中解放出来，并充分满足Ranadivé的原始愿景：实时动态地连接来自
通过软件总线将任何发布者分发给任何感兴趣的消费者。

**RabbitMQ的简要历史**


## 参考
* [1] https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html
* [2] https://aws.amazon.com/cn/message-queue/
* [3] https://aws.amazon.com/message-queue/benefits/#:~:text=Message%20queues%20enable%20asynchronous%20communication,only%20when%20they%20are%20available.
* [4] https://www.erlang-solutions.com/blog/an-introduction-to-rabbitmq-what-is-rabbitmq/
