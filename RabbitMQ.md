# RabbitMQ 分享

## 1. 内容列表
- [1. 内容列表](#1-内容列表)
- [2. 什么是消息队列](#2-什么是消息队列)
- [3. 为什么会有消息队列](#3-为什么要有消息队列)

## 2. 什么是消息队列？
消息排队允许应用程序通过相互发送消息进行通信。当目标程序繁忙或未连接时，消息队列将提供临时消息存储[1]。
消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载[2]。
![message queue](https://github.com/meiyingqishi/Images/blob/main/message-queue-small.png)

## 3. 为什么会有消息队列？
为了获得[3]：
- 更好的性能
> 消息队列支持异步通信，这意味着创建和处理消息的终端节点将与队列进行交互，而不是彼此交互。创建器可以将请求添加到队列中，无需再等待这些请求接受处理。处理器仅在消息可用时才会处理消息。系统中的任何组件都不会停下等待其他组件，从而优化了数据流。

- 增强的可靠性
> 队列可永久保留您的数据，并减少系统的不同部件离线时发生的错误。通过利用消息队列分离不同的组件，可以提高容错性。即使系统的某一部分无法访问，其他部分也仍可继续与队列进行交互。队列本身也可以进行镜像，以提供更高的可用性。

- 细化的可扩展性
> 消息队列可根据您的需要精确扩展。当工作负载到达峰值时，应用程序的多个实例都可以将请求添加到队列，而且不会产生冲突。随着队列因这些传入请求的增多而越来越长，您可以将这些工作负载分发给一组处理器。创建器、处理器和队列本身都可以按需扩展和缩减。

- 简化的分离功能
> 消息队列消除了组件之间的依赖关系，并显著简化了分离应用程序的编码。软件组件不必承担通信代码的重压，而是可以在经过设计后执行离散的业务功能。

## 4. 消息队列产生前都是怎样玩的？
当大量写请求，或者具体的说应该是瞬时大量的写请求到来时，既要保证系统的可用性还要保证尽量全部处理掉请求的情况下，我们应该怎么处理呢？
- **线程池**：池化技术在我们日常开发中是缓解系统压力的一个重要利器，但是对于线程池而言很难根据系统的瞬时流量来自动伸缩容量，而且自动伸缩流量并不是根治大流量到来办法。当池子满了以后也会影响部分情况的丢弃，最重要的是一旦服务宕机，那么所有的请求将化为乌有，除非你将线程池序列化，自己想想复杂度跟性能吧。
- **队列/缓存**：队列一般场景下都是使用空间换时间的另一种常用办法，但是它的弊病也存在需要自己开发一套序列化方案，保证服务异常恢复能正常处理后续任务。Redis的发布订阅者同样存在这些问题。

## 5. 什么是RabbitMQ？
RabbitMQ是一个免费的，开源的，可扩展的消息队列解决方案。 它是一个消息代理，可以理解AMQP（高级消息队列协议），但也可以与其他流行的消息解决方案（例如MQTT）一起使用。 它具有高可用性、容错性和可扩展性。 它在Erlang OTP中实现，该技术专为构建稳定、可靠、容错和高度可扩展的系统而设计，该系统具有处理大量并发操作的本机功能，例如RabbitMQ和其他系统（例如WhatsApp、MongooseIM等几个）。

在非常高的层次上，它是一个中间件层，使您的应用程序中的不同服务可以彼此通信，而不必担心消息丢失，同时提供不同的服务质量（QoS）要求。 它还可以实现细粒度和高效的消息路由，从而实现应用程序的广泛解耦[4]。

![rabbitmq flow](https://github.com/meiyingqishi/Images/blob/main/workflow-rabbitmq.png)

## 6. 为什么会有RabbitMQ？ 
在1983年，以为来自孟买的26岁软件工程师脑海里浮现了一个激进的想法：为社么没有一种通用的软件总线---一种通信系统，可以解决应用程序间繁重的信息通信工作呢？来自MIT的硬件设计教育工作者Vivek Ranadive设想了一种通用软件总线，就像主板上的总线那样供其它应用程序接入，因此，在1983年Teknekron诞生了。受伤掌握着崭新的哈佛MBA证书，脑袋里拥有强大的想法，Vivek为世界上各地的开发者开垦了一条捷径。

拥有美好的想法是一回事，而为它找到杀手级的应用则是另一回事。在1985年的高盛，Ranadive找到了它的第一位客户以及软件总线天生用来解决的问题：金融交易。当交易员的小隔间内挤满了用来完成交易的不同终端，每台终端上显示着不同类型的信息。Teknekron发觉这是个机会：替换掉所有那些终端和孤立的应用程序。在交易员的位置上的将会是Ranadive的软件总线。而桌上只会剩下一台工作站。而工作站的显示程序可以作为消费者接入Teknekron软件总线，并允许交易员“订阅”他想要看到的信息。于是发布订阅模式（PubSub)诞生了，同时还诞生了世界上第一个现代消息队列软件：Teknekron的The Information Bus（TIB）。

用不了多久，这种数据传输模型就找到了更多杀手级用途。最终，发布数据的应用和消费数据的应用再也不用直接连接在一起了。他们甚至都不需要对方的存在。Teknekron的TIB允许应用开发者建立一系列规则去描述消息内容。只要消息按照这些规则发布出去，任何消费者应用都能订阅感兴趣的消息。现在，信息的生产者和消费者之间完全解耦，并且可以在传输过程中灵活混合。PubSub模型的任意一边可以完全互换而不会影响到另一边。唯一需要保持未定的是TIB软件以及标记和路由信息规则。由于在那个时期金融交易行业门庭若市，因此TIB迅速传播开来。它引起了电信特别是新闻机构的注意。这些行业也特别需要将信息及时发布给千变万化的客户。这也解释了为什么在1994年大型新闻机构路透社收购了Teknekron。

与此同时，这个迅猛发展的企业软件引起了蓝色巨人的注意。毕竟IBM最大的几位客户都来自金融服务行业。而且，Teknekron的TIB软件通常会运行在IBM的硬件和操作系统上。除了White Plains的那群孩子外所有人都从中获得了好处。因此20世纪80年代后期，IBM开始研究开发自己的消息队列软件，运用他们在开发DB2时信息投递的丰富经验。开发工作起始于1990年，就在IBM的英国温切斯特附近的Hursely公园实验室。3年后，消息对列服务器软件IBM MQ产品系列面世。之后的17年，MQ系列进化成了WebSphere MQ并统治着商业消息队列平台市场。在那段时间，Ranadive的TIB并没有消失在路透腹中。相反，它仍然是企业通信市场的主要参与者，并且通过更名为Rendezvous而走向繁荣。在1997年Teknekron以TIBCO的形式作为一家独立公司再度出现。同年，微软也在消息通信市场展露头角：微软消息队列（MSMQ）。

通过这一系列的革新，消息队列软件主要留住了大型机构，它们需要可靠性、解耦以及实时消息通信。为什么MQ不去寻找更大的市场呢？它是如何度过20世纪90年代网络泡沫的呢？毕竟，从Twitter到Salesforce.com，当今所有的这些企业都在努力创建内部方案来解决25年前TIB就已经解决的PubSub问题。一句话：供应商壁垒。商业MQ供应商想要解决应用互通的问题，而不是去创建标准的接口来允许不同的MQ产品互通，或者（但愿不是这样）允许应用程序来更改MQ平台。供应商壁垒维持着足够搞得价格和利润率，并使得这些商业MQ软件对那些当今繁荣昌盛的初创公司Web 2.0公司来说遥不可及。

结果，中小技术公司并不是唯一一个对高价格MQ供应商感到不满的。那些早就MQ产业的金融服务公司对此也激动不起来。越是大型的金融公司越不可避免地使用来自众多供应商的MQ产品，来服务企业内部的不同应用。如果应用已经订阅了TIBCO MQ信息，若突然需要消费者来自IBM MQ的消息，则实现起来会非常困难。这些产品使用不同的API、不同协议，因而毫无疑问无法联合起来组成单一的总线。为了解决这个问题，Java Message Service(JMS)在2001年诞生了。JMS试图通过公共Java API的方式，隐藏单独MQ产品供应商提供的实际接口，从而跨越了壁垒和解决了互通问题。从技术上讲，Java应用程序只需针对JMS API编程，选择合适的MQ驱动即可。JMS会打理好其他部分。问题是你在尝试使用单独的标准化接口来胶合众多不同的接口。这就像是不同类型的衣服黏在一起：缝合处终究会裂开，真相会暴露出来。使用JMS的应用程序会变得更加脆弱。我们需要新的消息通信标准化方案[5]。

### 6.1. 救世主AMQP
2004年，JPMorgan Chase需要一个更好的消息通信解决方案，并开始和iMatix公司一起合作开发Advanced Message Queuing Protocol。AMQP从一开始就设计成开放标准，已解决众多的消息队列需求和拓扑结构问题。凭借开放，任何人都可以执行这一标准，针对标准编码的任何人都可以和任意AMQP供应商提供的MQ服务器进行交互。

在很多方面，AMQP承诺把我们从厂商的“地下城”中解决出来，并且实现Ranadive最初的愿景：从任何发布者到任何感兴趣的消费者之间的信息，通过一条软件总线实时动态连接起来。

### 6.2. RabbitMQ简史
在本世纪初，以为年轻的伦敦金融部门的企业家创办了一家专门研究Java对象缓存的公司：Metalogic。对Alexis Richardson来说，理论很简单：使用Java对象做分布式计算，同时为了传输性能对它们进行缓存。事实上却大相径庭。不同版本的虚拟机，以及客户端和服务器端不同的类库，都会使得接收到的对象不可用。Metalogic方法论的成功之路需要面对现实世界中太多的环境变数。Metalogic促成了Alexis和Matthias Radestock的会面。

Matthias在LShift工作，而Alexis正巧也在那里转租了一间办公室。当时LShift正投入和一家大型软件供应商的合同，专注于语言建模和分布式计算。这些领域方面的背景触发了Matthias对Erlang的兴趣。Erlang是Ericsson原本为电话交换机而开发的编程语言。引起Matthias注意的是Erlang在分布式编程和健壮性的故障恢复方面表现出色。可惜的是，当时Erlang不是开源的。同时，Metalogic结束了运营，LShift的主要分布式计算合同也接近尾声。Alexis在Metalogic的经历中学到了非常有价值的两课：分布式计算环境的工作机制和哪些公司需要这些环境。

Alexis知道自己想要开一家新的公司去解决分布式计算下的通信问题。他也知道他开的下一家公司将会是开源的，并且将采用JBoss和MySQL成功实践的模型。回顾Metalogic解决方案碰到的问题，Alexis逐渐认识到消息通信才是分布式计算的解决方案。更重要的是，2004年左右的技术领域正面临开源消息通信的空白。除了商业供应商外，没有人提供消息通信的解决方案。“企业”开源在数据库（MySQL）和应用服务器方面（JBoss）热火朝天，但却没有人去触碰消息通信那片空白。有趣的是：就在2004年，在JPMorgan Chase，AMQP正开始开发。因为在金融行业的背景，Alexis被引荐给了在JPMorgan的AMQP主要驱动者John O'Hara（将来的AMQP工作组创始人）。通过O'Hara，Alexis接触到了AMQP，并开始着手构建RabbitMQ。

在2005年左右，Alexis创办了CohesiveFT。他和他的合伙人在美国开办了公司，提供应用栈和工具，在今天逐渐成为云计算。对Alexis来说，应用栈的最关键部分是分布式消息通信。他（仍然在LShift那里办公）开始找Matthias探讨AMQP。Matthias清楚他已经找到了想要用Erlang实现的应用。但在动手之前，Alexis和Matthias聚焦在三个问题上。这三个问题是决定了用Erlang实现的AMQP开源版本能否成功的关键：
  * 那些大型金融机构是否会在意它们的消息代理服务器使用Erlang语言编写的？
  * Erlang语言是否真的是编写AMQP服务器的最佳选择？
  * 如果采用Erlang语言编写的话，是否会影响开源社区对它的采纳？
第一个问题立马就被一家金融公司解决了：他们不在乎软件是用什么语言编写的，只要它能够帮助减少集成上的花费即可。第二个问题由就职于Erlang Solutions的Francesco Cesarini回答：从他对AMQP的分析来看，这份规格说明展现的就是每一部电话交换机的架构。换句话说，你无法找到比Erlang更好的实现语言来构造AMQP代理服务器。最后一个问题则是被完全不同的消息通信服务区ejabberd解决了。知道2005年，Extensible Messaging and Presence Protocol（XMPP）已经逐渐成为受人尊敬的开放即时通信标准，并且首选的实现就是Alexey Shchepin编写的基于Erlang的ejabberd服务器包。ejabberd被广泛的使用在众多不同的组织机构里。它是由Erlang实现的这一点似乎并未阻挡其流行的步伐。

通过解决这三个主要问题，Alexis和Matthias说服了CohesiveFT和LShift共同支持这个项目。他们首先做的是签约Matthew Sackman（他现在是Rabbit核心开发员），让他用Erlang写了一个原型测试网络延迟。他们很快就发现用Erlang编写的分布式计算库有着和原生socket一样的延迟，简直不可思议。他们对名称很快有了共识：所有人都认可Rabbit这个名字。毕竟，兔子是行动非常迅速的动物且繁殖起来也非常疯狂，把它用于分布式软件的命名再合适不过了。至少选择Rabbit这个名字也便于记忆。因此在2006年，Rabbit Technologies诞生了：一家由CohesiveFT和LShift的合资企业，其拥有着RabbitMQ的知识产权。

时机总是如此的恰到好处，就在当时，AMQP规范的第一份公开草案也公之于世了。作为一份新的规范，AMQP正快速修订。这正是Erlang可以施展拳脚的地方。通过使用Erlang，RabbitMQ可以快速开发并跟上AMQP标准前进的节奏。令人惊讶的是，核心开发人员Tony Garnock-Jones仅仅用了两个半月的时间就将RabbitMQ 1.0版本开发完成了。最初，RabbitMQ实现了AMQP的一个关键特性，使其有别于TIBCO和IBM：使用协议本身就可以对像队列和交换器这样的资源进行配置。对商业供应商来说，资源配置需要通过特定的管理终端的特定工具才可以完成。RabbitMQ的资源配置能力使其成为构建分布式应用的最完美的通信总线，特别有助于充分利用基于云的资源和快速开发。

就这样一直到今天，RabbitMQ广泛使用在小到硅谷的初创公司，大到互联网巨头。对RabbitMQ来说，那也许是最好的事了，创始人感到非常惊讶：Rabbit的客户主要是技术公司而并非金融公司。对于那些只有少量预算同时也要解决消息通信的人来说，RabbitMQ实现了Ranadive的愿景。那正是RabbitMQ吸引我们的地方。我们并不知道自己是在找寻消息队列软件。我们知道的是自己需要解决应用集成和高强度事务处理负载的问题。RabbitMQ为我们提供了一个强大的工具来解决那些问题，并给我们带来了一段丰富的消息通信历史，以及适合所有人的可插拔的信息总线。

## 参考
* [1] https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html
* [2] https://aws.amazon.com/cn/message-queue/
* [3] https://aws.amazon.com/message-queue/benefits/#:~:text=Message%20queues%20enable%20asynchronous%20communication,only%20when%20they%20are%20available.
* [4] https://www.erlang-solutions.com/blog/an-introduction-to-rabbitmq-what-is-rabbitmq/
* [5] 《RabbitMQ in Action》
