# RabbitMQ 分享

## 1. 内容列表
- [1. 内容列表](#1-内容列表)
- [2. 什么是消息队列](#2-什么是消息队列)
- [3. 为什么要有消息队列](#3-为什么要有消息队列)

## 2. 什么是消息队列
消息排队允许应用程序通过相互发送消息进行通信。当目标程序繁忙或未连接时，消息队列将提供临时消息存储[1]。
消息队列是一种异步的服务间通信方式，适用于无服务器和微服务架构。消息在被处理和删除之前一直存储在队列上。每条消息仅可被一位用户处理一次。消息队列可被用于分离重量级处理、缓冲或批处理工作以及缓解高峰期工作负载[2]。
![message queue](https://github.com/meiyingqishi/Images/blob/main/message-queue-small.png)

## 3. 为什么要有消息队列
为了获得[3]：
- 更好的性能
> 消息队列支持异步通信，这意味着创建和处理消息的终端节点将与队列进行交互，而不是彼此交互。创建器可以将请求添加到队列中，无需再等待这些请求接受处理。处理器仅在消息可用时才会处理消息。系统中的任何组件都不会停下等待其他组件，从而优化了数据流。

- 增强的可靠性
> 队列可永久保留您的数据，并减少系统的不同部件离线时发生的错误。通过利用消息队列分离不同的组件，可以提高容错性。即使系统的某一部分无法访问，其他部分也仍可继续与队列进行交互。队列本身也可以进行镜像，以提供更高的可用性。

- 细化的可扩展性
> 消息队列可根据您的需要精确扩展。当工作负载到达峰值时，应用程序的多个实例都可以将请求添加到队列，而且不会产生冲突。随着队列因这些传入请求的增多而越来越长，您可以将这些工作负载分发给一组处理器。创建器、处理器和队列本身都可以按需扩展和缩减。

- 简化的分离功能
> 消息队列消除了组件之间的依赖关系，并显著简化了分离应用程序的编码。软件组件不必承担通信代码的重压，而是可以在经过设计后执行离散的业务功能。

## 4. 消息队列产生前都是怎样玩的
当大量写请求，或者具体的说应该是瞬时大量的写请求到来时，既要保证系统的可用性还要保证尽量全部处理掉请求的情况下，我们应该怎么处理呢？
- **线程池**：池化技术在我们日常开发中是缓解系统压力的一个重要利器，但是对于线程池而言很难根据系统的瞬时流量来自动伸缩容量，而且自动伸缩流量并不是根治大流量到来办法。当池子满了以后也会影响部分情况的丢弃，最重要的是一旦服务宕机，那么所有的请求将化为乌有，除非你将线程池序列化，自己想想复杂度跟性能吧。
- **队列/缓存**：队列一般场景下都是使用空间换时间的另一种常用办法，但是它的弊病也存在需要自己开发一套序列化方案，保证服务异常恢复能正常处理后续任务。Redis的发布订阅者同样存在这些问题。

## 5. 什么是RabbitMQ
RabbitMQ是一个免费的，开源的，可扩展的消息队列解决方案。 它是一个消息代理，可以理解AMQP（高级消息队列协议），但也可以与其他流行的消息解决方案（例如MQTT）一起使用。 它具有高可用性、容错性和可扩展性。 它在Erlang OTP中实现，该技术专为构建稳定、可靠、容错和高度可扩展的系统而设计，该系统具有处理大量并发操作的本机功能，例如RabbitMQ和其他系统（例如WhatsApp、MongooseIM等几个）。

在非常高的层次上，它是一个中间件层，使您的应用程序中的不同服务可以彼此通信，而不必担心消息丢失，同时提供不同的服务质量（QoS）要求。 它还可以实现细粒度和高效的消息路由，从而实现应用程序的广泛解耦[4]。

![rabbitmq flow](https://github.com/meiyingqishi/Images/blob/main/workflow-rabbitmq.png)

## 6. 为什么要有RabbitMQ


## 参考
* [1] https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html
* [2] https://aws.amazon.com/cn/message-queue/
* [3] https://aws.amazon.com/message-queue/benefits/#:~:text=Message%20queues%20enable%20asynchronous%20communication,only%20when%20they%20are%20available.
* [4] https://www.erlang-solutions.com/blog/an-introduction-to-rabbitmq-what-is-rabbitmq/
